# 属性和方法

>**属性**
>
>* 存储属性 （Stored Properties）
>* 计算属性  (Computed Properties)
>* 属性观察器 (Property Observers)
>* 类型属性   （Class Properties）
>* 全局变量和局部变量
>
>**函数**
>
>* 函数的定义
>* 函数的参数和返回值
>* 函数参数名称
>* 嵌套函数
>
>**方法**
>
>* 实例方法 (Instance Methods)>
>* 类方法  (Type Methods)
>* 方法的局部参数名和外部参数名 (Local and External Parameter Names for Methods)

### 属性
**存储属性**

变量存储属性和常量存储树新，可以在定义存储属性时指定默认值，也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值。

~~~swift
struct Cup {
	var capacity:Int  //变量存储属性
	let material:String //常量存储属性
}

var cup = Cup(capacity: 300, material: "glass")
//常量属性一旦被初始化，就不能被修改了
~~~

**延迟存储属性**

延迟存储属性只有在第一次调用的时候才会计算其初始值得属性。在属性声明前使用lazy来标示一个延迟存储属性。

**!!!**

*延迟属性必须声明为变量，因为延迟属性的初始值可能在实例构造完成后才会得到。而常量属性在构造完成之前必须要有初始值，因此无法声明延迟属性*

**计算属性**

计算属性不直接存储值，而是提供一个getter和一个setter，来间接获取和设置其他属性或变量的值。
~~~swift
struct Cup {
	var capacity:Int  //变量存储属性
	let material:String {
		get {
			return material
		}
		set(newValue) {
			material = newValue
		}
	}
}
~~~

**便捷setter**

setter没有定义表示新值得参数名，可以使用默认名称newValue。

**只读计算属性**

只有getter，没有setter的计算属性就是只读属性，定义的时候可以去掉，get关键字和花括号。

**!!!**

*注意必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let关键字只用来声明常量属性，表示初始化后再也无法修改的值。*

### 属性观察器

属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新值和当前值相同的时候也不例外。

可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性

**!!!**
不需要为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。(不太理解)
* willSet 在新的值被设置之前调用
* didSet 在新的值被设置之后被立即调用

~~~swift
class StepCounter {
    var totalSteps: Int = 0 {
        willSet(newTotalSteps) {
            print("About to set totalSteps to \(newTotalSteps)")
        }
        didSet {
            if totalSteps > oldValue  {
                print("Added \(totalSteps - oldValue) steps")
            }
        }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
stepCounter.totalSteps = 360
// About to set totalSteps to 360
// Added 160 steps
stepCounter.totalSteps = 896
// About to set totalSteps to 896
// Added 536 steps
~~~
### 类型属性也就是常说的类变量

类变量是属于一个类的变量，可以通过类名直接访问，存储类型属性必须要指定默认值，这是因为类本身没有构造器，存储型类属性是延迟初始化的，而且不需要对其使用lazy修饰符。

**类型属性定义语法**

~~~
使用关键字 static
struct Person {
    static var age = 20
    static var name = "tom"
    var height: Int
}

var p = Person(height: 170)
print("this is class Properties \(Person.age), \(Person.name)")
//类属性直接用类名调用
~~~

### 函数

**定义**

~~~swift
function name() -> 返回值类型 {
	//函数体
}
~~~

**参数与返回值**
无参数这个没什么记得

**多参数**

~~~swift
func addString(string1: String, string2: String) -> String {
    return string1  + string2
}

print(addString("say", string2: " hello"))
//输出say hello
~~~

**无返回值的函数**

就是没有任何返回值的函数，省略掉返回值声明，实际上没有定义返回类型的函数会返回特殊值，叫Void，Void是一个元组（tuple）,没有任何元素，可以写成()。

**多重返回函数**
利用元组(tuple)类型让多个值作为一个复合值从函数中返回。

~~~swift
func retunHeadAndTail(str: String) -> (head: Character, tail: Character) {
    return(str[str.startIndex], str[str.endIndex.predecessor()])
}

var ht = retunHeadAndTail("say hello")
print("\(ht.head), \(ht.tail)")
//s,o
~~~

**可选元组返回类型**

~~~swift
func retunHeadAndTail(str: String) -> (head: Character, tail: Character)？ {
    return(str[str.startIndex], str[str.endIndex.predecessor()])
}
~~~

### 函数的参数名称

函数参数都有一个外部参数名，和一个局部参数名，外部参数名用于在函数调用时标注传递给函数的参数，局部参数名在函数的实现内部使用。

~~~swift
func addString(string1: String, string2: String) -> String {
    return string1  + string2
}

print(addString("say", string2: " hello"))
//输出say hello
~~~

可以看到一般情况下，第一个参数省略其外部参数名，第二个以及随后的参数使用其局部参数名作为外部参数名。所有参数必须有独一无二的局部参数名。尽管多个参数可以有相同的外部参数名，但不同的外部参数名能让你的代码更有可读性。

### 制定外部参数名
你可以在局部参数名前指定外部参数名，中间以空格分隔：有一个注意点就是如果你提供了外部参数名，调用函数时必须使用外部参数名。

~~~swift
func name(exterParaName localParaName: Int) {

}
~~~

### 忽略外部参数名

如果你不想为第二个及后续的参数设置外部参数名，用一个下划线(_)代替一个明确的参数名。
~~~swift
func someFunction(FirstName: Int, _ secondName) {

}
~~~

##### 默认参数值
~~~swift
func removeLastChar(str: String = "this is a string") {

}
removeLastChar("hahaha")
removeLastchar()//使用参数的默认值
~~~
#### ！！！
*将带有默认值的参数放在参数列表最后。这样可以保证在函数调用时，非默认参数的顺序是一致的，同时使得相同函数在不同情况下调用时显得更为清晰*

##### 可变参数(Variadic Parameters)
语法通过在变量类型名后面加入(...)的方式定义可变参数。可变参数的传入值在函数体中变为此类型的一个数组。

~~~swift
func add(numbers: Int...)->Int {
	var total: Int = 0
	for number in numbers {
		total += number
	}
	return total
}
~~~

##### 输入输出参数

变量参数，正如上面所述，仅仅能在函数体内被更改。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）。
定义一个输入输出参数时，在参数定义前加 inout 关键字。一个输入输出参数有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。
你只能传递变量给输入输出参数。你不能传入常量或者字面量（literal value），因为这些量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加&符，表示这个值可以被函数修改。
#### ！！！
注意
输入输出参数不能有默认值，而且可变参数不能用 inout 标记。如果你用 inout 标记一个参数，这个参数不能被 var 或者 let 标记。
~~~swift
func swapTwoInts(inout a: Int, inout _ b: Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

ar someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// prints "someInt is now 107, and anotherInt is now 3"
~~~

**这个符号（&）的用法有点像c++中的引用符号**

#### 函数类型(Function Types)

每个函数都有种特定的函数类型，由函数的参数类型和返回类型组成。

~~~swift
func addTwoInts(a: Int, _ b: Int) -> Int {
    return a + b
}
func multiplyTwoInts(a: Int, _ b: Int) -> Int {
    return a * b
}//函数类型为(Int, Int) -> Int
func printHelloWorld() {
    print("hello, world")
}//() -> Void
~~~
使用函数类型和使用普通类型一样，你可以定义一个函数类型的变量并将一个此函数类型的函数赋给这个变量。
~~~swift
var mathFunction: (Int, Int) -> Int = addTwoInts

mathFunction(2, 3)
~~~

**函数类型也可以作为参数类型**
也就是说把一个函数，当做另一个函数的参数传进去
（例子以后再补充）
**函数作为返回类型**
既然函数类型和普通类型没有什么区别，那函数当然可以作为函数的返回类型了。

##### 嵌套函数

可以把函数定义在其他函数体中，称作嵌套函数，默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数（enclosing function）调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。

